/**
 * Created by tom on 11/10/14.
 */
THREE.AtmosphereShader = {
  uniforms:{
    p_r: {type: 'v3', value: new THREE.Vector3(6378141.2, 6378141.2, 6356754.79506139)},
    sun_dir: {type: 'v3', value: new THREE.Vector3()},
    sun_col: {type: 'v3', value: new THREE.Color()},
    sun_posr: {type: 'v4', value: new THREE.Vector4()},
    B0: {type: 'v4', value: new THREE.Vector4(0.1981, 0.4656, 0.8625, 0.75)}
  },
  vertexShader: [
    'varying vec3 pixel_nor;',
    'varying vec4 pixel_pos;',
    'varying vec4 pixel_scr;',
    'uniform vec3 p_r;',
    'void main(void){',
    ' pixel_nor=gl_Normal;',
    ' pixel_pos=gl_Vertex;',
    ' pixel_scr=gl_Color;',
    ' gl_Position=gl_Color;',
    '}'
  ].join('\n'),
  fragmentShader: [
    '#extension GL_ARB_gpu_shader_fp64 : enable',
    'double abs(double x) { if (x < 0.0) x=-x; return x; }',
    'varying vec3 pixel_nor;',
    'varying vec4 pixel_pos;',
    'varying vec4 pixel_scr;',

    'uniform vec3 p_r;',
    'uniform vec3 sun_dir;',
    'uniform vec3 sun_col;',
    'uniform vec4 sun_posr;',
    'uniform vec4 B0',

    'const double view_depth_max = 100000000.0;',
    'float planet_h = p_r.x * 480000.0/6378141.2;',
    'float view_depth = planet_h/2;',
    'double view_depth_l0=-1.0;',
    'double view_depth_l1=-1.0;',
    'bool _view_depth_l0=false;',
    'bool _view_depth_l1=false;',

    'bool _view_depth(vec3 _p0, vec3 _dp, vec3 _r){',
    ' dvec3 p0, dp, r;',
    ' double a, b, c, d, l0, l1;',
    ' view_depth_l0=-1.0; _view_depth_l0=false;',
    ' view_depth_l1=-1.0; _view_depth_l1=false;',
    ' p0=dvec3(_p0);',
    ' dp=dvec3(_dp);',
    ' r =dvec3(_r );',
    ' a=(dp.x * dp.x * r.x) + (dp.y * dp.y * r.y) + (dp.z * dp.z * r.z);',
    ' b=(p0.x * dp.x * r.x) + (p0.y * dp.y * r.y) + (p0.z * dp.z * r.z);',
    ' b*=2.0;',
    ' c=(p0.x * p0.x * r.x) + (p0.y * p0.y * r.y) + (p0.z * p0.z * r.z) - 1.0;',
    ' d=((b*b)-(4.0*a*c));',
    ' if (d<0.0) { return false; }',
    ' d=sqrt(d);',
    ' a*=2;',
    ' l0=(-b+d)/a;',
    ' l1=(-b-d)/a;',
    ' if ((l0<0.0)||((l1<l0)&&(l1>=0.0))) { a=l0; l0=l1; l1=a; }',
    ' if (l1>=0.0) { view_depth_l1=l1; _view_depth_l1=true; }',
    ' if (l0>=0.0) { view_depth_l0=l0; _view_depth_l0=true; return true; }',
    ' return false;',
    '}',

    'bool _star_collide(vec3 _p0, vec3 _dp, float _r) {',
    ' dvec3 p0, dp, r;',
    ' double a, b, c, d, l0, l1;',
    ' p0=dvec3(_p0);',
    ' dp=dvec3(_dp);',
    ' r =dvec3(_r );',
    ' a=(dp.x * dp.x * r.x) + (dp.y * dp.y * r.y) + (dp.z * dp.z * r.z);',
    ' b=(p0.x * dp.x * r.x) + (p0.y * dp.y * r.y) + (p0.z * dp.z * r.z);',
    ' b*=2.0;',
    ' c=(p0.x * p0.x * r.x) + (p0.y * p0.y * r.y) + (p0.z * p0.z * r.z) - 1.0;',
    ' d=((b*b)-(4.0*a*c));',
    ' if (d<0.0) { return false };',
    ' d=sqrt(d);',
    ' a*=2;',
    ' l0=(-b+d)/a;',
    ' l1=(-b-d)/a;',
    ' if (abs(l0)>abs(l1)) { a=l0; l0=l1; l1=a; }',
    ' if (l0<0.0)          { a=l0; l0=l1; l1=a; }',
    ' if (l0<0.0) { return false; }',
    ' return true;',
    '}',

    'vec4 atmosphere() {',
    ' const int n=8;',
    ' const float _n=1.0/float(n);',
    ' int i;',
    ' bool b0, b1;',
    ' vec3 p0, p1, dp, p, b, a_r, p_R, a_R;',
    ' vec4 c;',
    ' float h, dl, ll;',
    ' double l0, l1, l2;',
    ' a_r.x=p_r.x+planet_h;',
    ' a_r.y=p_r.y+planet_h;',
    ' a_r.z=p_r.z+planet_h;',
    ' p_R.x=1.0/(p_r.x*p_r.x);',
    ' p_R.y=1.0/(p_r.y*p_r.y);',
    ' p_R.z=1.0/(p_r.z*p_r.z);',
    ' a_R.x=1.0/(a_r.x*a_r.x);',
    ' a_R.y=1.0/(a_r.y*a_r.y);',
    ' a_R.z=1.0/(a_r.z*a_r.z);',


    ' c=vec4(0.0, 0.0, 0.0, 0.0);',
    ' b1=view_depth(pixel_pos.xyz, pixel_nor, a_R);',
    ' if (!b1) { return c; }',
    ' e1=_view_depth_l0; l1=view_depth_l0;',
    ' e2=_view_depth_l1; l2=view_depth_l1;',
    ' b0=_view_depth(pixel_pos.xyz, pixel_nor, p_R);',
    ' e0=_view_depth_l0; l0=view_depth_l0;',
    ' if ((b0)&&(view_depth_l1<0.0)) return c;',
    ' dp=pixel_nor;',
    ' p0=pixel_pos.xyz;',
    ' if (!b0) {',
    '  if (!e2) {',
    '   l0=l1;',
    '  } else {',
    '   p0=vec3(dvec3(p0)+(dvec3(dp)*l1));',
    '   l0=l2-l1;',
    '  }',
    '  if (_star_collide(p0.xyz-sun.posr.xyz, dp.xyz, sun_posr.a)) {',
    '   c.rgb+=sun_col;',
    '   c.a=1.0',
    '  }',
    ' } else {',
    '  if (l1<l0) {',
    '   p0=vec3(dvec3(p0)+(dvec3(dp)*l1));',
    '   l0=l0-l1;',
    '  }',
    ' }',
    ' p1=vec3(dvec(p0)+(dvec(dp)*l0));',
    ' dp=p1-p0;',
    ' dp*=_n;',
    ' dl=float(l0)*_n/view_depth;',
    ' ll=B0.a;',
    ' ll+=dot(normalize(p1), sun_dir);',
    ' for (p=p1, i=0; i<n; p-=dp, i++) {',
    '  b=normalize(p).p_r;',
    '  h=length(p-b);',
    '  h=exp(h/planet_h)/2.78;',
    '  b=B0.rgb*h*dl;',
    '  c.r*=1.0-b.r;',
    '  c.g*=1.0-b.g;',
    '  c.b*=1.0-b.b;',
    '  c.rgb+=b*ll;',
    ' }',
    ' if (c.r<0.0) { c.r=0.0; }',
    ' if (c.g<0.0) { c.g=0.0; }',
    ' if (c.b<0.0) { c.b=0.0; }',
    ' h=0.0;',
    ' if (h<c.r) { h=c.r; }',
    ' if (h<c.g) { h=c.g; }',
    ' if (h<c.b) { h=c.b; }',
    ' if (h>1.0) {',
    '  h=1.0/h;',
    '  c.r*=h;',
    '  c.g*=h;',
    '  c.b*=h;',
    ' }',
    ' return c;',
    '}',

    'void main(void) {',
    ' gl_FragColor.rgba=atmosphere();',
    '}'
  ].join('\n')
};